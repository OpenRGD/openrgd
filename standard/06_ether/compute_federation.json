{
  "meta_group": {
    "compute_federation_id_str": "core_compute_federation_v1",
    "version_semver_str": "1.0.0",
    "last_updated_iso8601_str": "2025-11-23T18:40:00Z",
    "license_enum": "MIT_OPEN_AICOG",
    "governance": {
      "stewardship_organization_str": "OpenRGD Consortium",
      "lead_maintainer_str": "Pasquale Ranieri",
      "maintainer_role_enum": "COMPUTE_FEDERATION_ARCHITECT",
      "contact_uri_str": "mailto:federation@openrgd.org"
    }
  },
  "federation_role": {
    "role_enum": "COMPUTE_CLIENT",
    "role_description_str": "Low-capacity mobile agent seeking external compute for complex tasks.",
    "allow_dynamic_role_switch_bool": true,
    "allowed_roles_list": [
      "COMPUTE_CLIENT",
      "COMPUTE_HOST"
    ]
  },
  "task_offload_catalog": {
    "task_types_list": [
      "PATH_PLANNING",
      "OBJECT_RECOGNITION",
      "SCENE_UNDERSTANDING",
      "LLM_REASONING"
    ],
    "task_safety_constraints_map": {
      "PATH_PLANNING": {
        "allow_remote_control_over_actuators_bool": false,
        "max_latency_ms_int": 50,
        "requires_failsafe_local_backup_bool": true
      },
      "OBJECT_RECOGNITION": {
        "allow_partial_results_bool": true,
        "max_latency_ms_int": 150,
        "requires_failsafe_local_backup_bool": false
      },
      "LLM_REASONING": {
        "allow_content_filtering_by_host_bool": true,
        "max_latency_ms_int": 500,
        "requires_failsafe_local_backup_bool": false
      }
    }
  },
  "economic_model": {
    "unit_enum": "COMPUTE_TOKEN",
    "max_cost_per_1k_tokens_float": 0.001,
    "energy_budget_ratio_float": 0.3,
    "cooperative_discount_policy": {
      "enable_cooperative_discount_bool": true,
      "max_discount_ratio_float": 0.8,
      "required_trust_score_min_float": 0.85,
      "required_same_swarm_bool": true
    }
  },
  "security_policy": {
    "encryption_enum": "HOMOMORPHIC_PREFERRED",
    "allow_plaintext_fallback_bool": false,
    "non_exportable_data_categories_list": [
      "RAW_HUMAN_BIOMETRICS",
      "UNMASKED_IDENTIFIERS",
      "ALIGNMENT_CORE_WEIGHTS"
    ],
    "alignment_check_policy": {
      "require_alignment_precheck_bool": true,
      "alignment_profile_id_str": "core_safety_alignment_v1",
      "defined_in_file_str": "04_volition/alignment.json"
    }
  },
  "host_selection_policy": {
    "selection_mode_enum": "TRUST_AWARE_NEAREST",
    "max_search_radius_m_float": 50.0,
    "max_candidate_hosts_int": 5,
    "trust_integration": {
      "reputation_graph_enabled_bool": true,
      "min_trust_score_threshold_float": 0.6,
      "prefer_high_reputation_hosts_bool": true,
      "reputation_file_ref_str": "06_ether/reputation_graph.json"
    }
  },
  "qos_and_fallback_policy": {
    "global_max_latency_ms_int": 500,
    "max_retry_attempts_int": 2,
    "retry_backoff_ms_int": 100,
    "fallback_behaviour": {
      "on_timeout_enum": "USE_LOCAL_APPROXIMATION",
      "on_host_failure_enum": "BLACKLIST_HOST_TEMPORARILY",
      "local_approximation_notes_str": "Use reduced-resolution planning or degraded perception models when remote compute fails."
    }
  },
  "offload_request_template": {
    "fields_list": [
      {
        "field_name_str": "task_type_enum",
        "description_str": "Type of computation to offload (must be listed in 'task_offload_catalog')."
      },
      {
        "field_name_str": "input_tensor_shape_list",
        "description_str": "Shape of the input data tensor (e.g., [batch, height, width, channels])."
      },
      {
        "field_name_str": "max_tokens_budget_float",
        "description_str": "Maximum allowed compute cost for this request, in federation tokens."
      },
      {
        "field_name_str": "deadline_ms_int",
        "description_str": "Soft deadline after which results may be discarded or downgraded."
      },
      {
        "field_name_str": "privacy_level_enum",
        "description_str": "Requested privacy level (e.g., STRICT, BALANCED, RELAXED) mapping to encryption and data minimization."
      }
    ]
  },
  "logging_and_accounting": {
    "enable_usage_logging_bool": true,
    "log_channel_str": "ledger://compute_federation_events",
    "store_per_task_stats_bool": true,
    "fields_to_log_list": [
      "task_type_enum",
      "host_agent_id",
      "latency_ms",
      "tokens_spent",
      "success_bool"
    ]
  },
  "runtime_interpretation": {
    "used_by_components_list": [
      "03_agency/swarm_protocol.json",
      "06_ether/consensus_reality.json",
      "06_ether/reputation_graph.json"
    ],
    "is_optional_feature_bool": true,
    "semantic_notes_str": "Compute federation should be treated as an augmentative capability, not a dependency. Agents must remain capable of entering a safe degraded mode without external compute."
  }
}