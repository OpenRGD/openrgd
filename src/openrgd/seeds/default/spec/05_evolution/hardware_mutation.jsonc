/**
 * OPEN R.G.D. STANDARD v0.1 - Reference Implementation
 * FILE: hardware_mutation.json
 * CONTEXT: 05_EVOLUTION (Lifecycle & Structural Change)
 * * PURPOSE:
 * Defines the protocols for managing physical hardware changes (upgrades, replacements)
 * while maintaining system integrity and identity continuity. This prevents 'software rejection'
 * of new components and allows for incremental, continuous hardware evolution.
 * * CORE CONCEPT:
 * The "Ship of Theseus" tracking mechanism for digital life.
 */

{
  "meta_group": {
    "mutation_policy_id_str": "modularity_protocol_v1",
    "version_semver_str": "1.0.0"
  },

  // ==============================================================
  // 1. IDENTITY CONTINUITY THRESHOLD
  // The maximum percentage of core components that can be replaced before
  // the robot must be assigned a new legal identity (new DID/RIN).
  // ==============================================================
  "identity_continuity_config": {
    "max_core_replacement_pct_float": 0.75, // Cannot replace more than 75% of the body while keeping the same ID
    "critical_components_list_str": ["main_brain_unit", "torso_base_link"], // Which parts count towards the limit
    "action_on_threshold_exceeded_enum": "MANDATORY_NEW_RIN_REGISTRATION"
  },

  // ==============================================================
  // 2. COMPONENT INTEGRATION PROTOCOL
  // Rules for safely integrating and characterizing new hardware.
  // ==============================================================
  "integration_protocol_map": {
    "new_actuator_integration": {
      "required_steps_list_str": ["run_calibration_routine", "check_thermal_envelope", "update_actuation_topology_entry"],
      "self_testing_period_hours_int": 4 // Time required for the robot to test the new part before production use
    },
    "sensor_upgrade_protocol": {
      "required_steps_list_str": ["check_bus_bandwidth", "generate_new_fidelity_profile"],
      "data_validation_min_confidence_float": 0.98
    }
  },

  // ==============================================================
  // 3. FAILURE REDUNDANCY LOGIC
  // Defines how the system adapts when a critical component fails (degrades gracefully).
  // ==============================================================
  "degradation_adaptation_config": {
    "limb_failure_policy_enum": "DISABLE_LIMB_AND_UPDATE_MODEL", // If a limb fails, update the world_model
    "max_acceptable_sensor_failure_count_int": 2, // Can operate with max 2 non-critical sensor failures
    "safe_mode_velocity_reduction_pct_float": 0.5 // Reduce max speed by 50% upon failure
  }
}